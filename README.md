# COMET Programming Language

**C**ompiled **O**ptimized **M**odular **E**xpression **T**ranslator

A lexer and parser that compiles the COMET programming language to LuaJIT bytecode.

## Features

- **Lexical Analysis**: Flex-based lexer for tokenization
- **Syntax Parsing**: Bison-based parser with full AST generation
- **Code Generation**: Emits valid Lua code during parsing
- **Bytecode Compilation**: Automatically compiles to LuaJIT bytecode

## COMET Language Features

COMET supports:
- **Variable declarations** with type annotations (bool, number, string, array)
- **Arrays**: homogeneous typed arrays and heterogeneous mixed-type arrays with nesting support
- **Strings**: escape sequences, interpolation with `${}`, and concatenation with `..`
- **String/Array operations**: length operator `#` for both strings and arrays
- **Functions** with parameters, return types, and return statements
- **Operators**: arithmetic (+, -, *, /), string concatenation (..),  comparison (==, !=, <, >, <=, >=), logical (&&, ||)
- **Compound assignments** (+=, -=, *=, /=)
- **Control flow**: conditional blocks with otherwise/else/elseif, while-style loops, nested structures, break/continue in loops and conditionals
- **Input/Output**: print() and input() operations
- **Expressions**: complex expressions with proper operator precedence
- **Comments**: lines starting with #

## Building

```bash
make
```

Requires: `flex`, `bison`, `gcc`, and `luajit`

## Usage

Compile a COMET source file to LuaJIT bytecode:

```bash
./parser <input_file> [output_bytecode]
```

**Examples:**
```bash
./parser program.comet output.bc       # Generates output.bc
./parser hello.comet                   # Generates a.out
```

The compiler will:
1. Parse the COMET source file
2. Generate intermediate Lua source (saved as `<output>.bc.lua`)
3. Compile to LuaJIT bytecode using luajit

## Running Bytecode

Execute the generated bytecode with:

```bash
luajit output.bc
```

## Example COMET Program

```comet
# Variables with type annotations
let x: number = 42
let y: number = 3.14

# String literals with escape sequences
let msg: string = "Hello\nWorld"
let quoted: string = "She said \"Hi\""

# String concatenation and interpolation
let name = "World"
let greeting = "Hello" .. " " .. name
let info = "String length: " .. tostring(#greeting)

# Arrays: homogeneous and heterogeneous
let numbers: number[] = [1, 2, 3]
let mixed = [42, "text", true]
let nested = [1, [2, 3], [4, [5, 6]]]

# print() does NOT add newlines automatically
print(msg)
print("\n")
print(greeting)
print("\n")
print(info)
print("\n")

# Conditional blocks with otherwise/else
(x > 40)?
  print("x is greater")
otherwise?
  print("x is not greater")
done
print("\n")

# Conditional with elseif
(y > 5)?
  print("y > 5")
otherwise (y == 5)?
  print("y == 5")
otherwise?
  print("y < 5")
done
print("\n")

# Functions with return statements
function add(a: number, b: number) -> number
  return a + b
done

# Loops with nested conditionals and break
let i: number = 1;
until (i > 5)?
  (i == 3)?
    print("Breaking at 3")
    print("\n")
    break  // Exit loop
  done
  print(i)
  print("\n")
  i += 1
done

# Nested conditionals with continue
let j: number = 1;
until (j > 3)?
  (j == 2)?
    print("Skipping 2")
    print("\n")
    continue  // Skip to next iteration
  done
  print(j)
  print("\n")
  j += 1
done

# Function calls
print(add(x, y))
print("\n")
```

See `comprehensive_test.txt` for a complete test suite covering all COMET features.

## Implementation

- `lexer.l` - Flex lexical analyzer (COMET tokenization)
- `parser.y` - Bison parser with semantic actions (COMET to Lua translation)
- `Makefile` - Build configuration

The COMET compiler generates Lua code during parsing using semantic actions, which is then compiled to bytecode by LuaJIT.

## Clean

```bash
make clean
```

Removes compiled artifacts (parser binary and object files).
