# COMET Programming Language

**C**ompiled **O**ptimized **M**odular **E**xpression **T**ranslator

A lexer and parser that compiles the COMET programming language to LuaJIT bytecode.

## Features

- **Lexical Analysis**: Flex-based lexer for tokenization
- **Syntax Parsing**: Bison-based parser with full AST generation
- **Code Generation**: Emits valid Lua code during parsing
- **Bytecode Compilation**: Automatically compiles to LuaJIT bytecode

## COMET Language Features

COMET supports:
- **Variable declarations** with type annotations (bool, number, string, array)
- **Union types** (e.g., `number | string`) for flexible typing
- **Arrays**: homogeneous typed arrays and heterogeneous mixed-type arrays with nesting support
- **Arrays as parameters**: functions can accept arrays as typed parameters with `#` operator support
- **Array manipulation**: `push()`, `pop()`, `insert()` functions for dynamic array operations
- **Strings**: escape sequences, interpolation with `${}`, and concatenation with `..`
- **String/Array operations**: length operator `#` for both strings and arrays
- **Functions**: parameters, return types, return statements, and variadic arguments (`...`)
- **Type checking methods**: `.isnumber`, `.isstring`, `.isbool` for runtime type checking
- **Function types**: type annotations for callable signatures
- **Shell commands**: `runcmd()` function for executing system commands
- **Operators**: arithmetic (+, -, *, /), string concatenation (..),  comparison (==, !=, <, >, <=, >=), logical (&&, ||)
- **Compound assignments** (+=, -=, *=, /=)
- **Control flow**: conditional blocks with otherwise/else/elseif, while-style loops, nested structures, break/continue in loops and conditionals
- **Input/Output**: print() and input() operations
- **Expressions**: complex expressions with proper operator precedence
- **Comments**: lines starting with #

## Building

```bash
make
```

Requires: `flex`, `bison`, `gcc`, and `luajit` (with bytecode support)

## Usage

Compile a COMET source file to LuaJIT bytecode:

```bash
./parser <input_file> [output_bytecode]
```

**Examples:**
```bash
./parser program.comet output.bc       # Generates output.bc (LuaJIT bytecode)
./parser hello.comet                   # Generates a.out (LuaJIT bytecode)
```

The compiler will:
1. Parse the COMET source file
2. Generate equivalent Lua source code (during parsing)
3. Emit LuaJIT bytecode directly using Lua's dump function
4. Optionally save intermediate Lua as `<output>.bc.lua` for reference

## Running Bytecode

Execute the generated bytecode with:

```bash
luajit output.bc
```

## Example COMET Program

```comet
# Variables with type annotations
let x: number = 42
let y: number = 3.14

# String literals with escape sequences
let msg: string = "Hello\nWorld"
let quoted: string = "She said \"Hi\""

# String concatenation and interpolation
let name = "World"
let greeting = "Hello" .. " " .. name
let info = "String length: " .. tostring(#greeting)

# Arrays: homogeneous and heterogeneous
let numbers: number[] = [1, 2, 3]
let mixed = [42, "text", true]
let nested = [1, [2, 3], [4, [5, 6]]]

# print() does NOT add newlines automatically
print(msg)
print("\n")
print(greeting)
print("\n")
print(info)
print("\n")

# Conditional blocks with otherwise/else
(x > 40)?
  print("x is greater")
otherwise?
  print("x is not greater")
done
print("\n")

# Conditional with elseif
(y > 5)?
  print("y > 5")
otherwise (y == 5)?
  print("y == 5")
otherwise?
  print("y < 5")
done
print("\n")

# Functions with return statements
function add(a: number, b: number) -> number
  return a + b
done

# Function with array parameter - can use # operator
function sumarray(nums: number[]) -> number
  return #nums
done

# Function with variadic arguments
function concat(...items) -> string
  return "combined"
done

# Union types for flexible parameters
function process(value: number | string) -> string
  return "processed"
done

# Array manipulation
let arr: number[] = [1, 2, 3]
push(arr, 4)           # Add to end: [1, 2, 3, 4]
pop(arr)               # Remove from end: [1, 2, 3]
insert(arr, 2, 99)     # Insert at position 2: [1, 99, 2, 3]

# Shell commands
runcmd("echo Running")
let status = runcmd("test -f file.txt")
(status == 0)?
  print("File exists")
done

# Loops with nested conditionals and break
let i: number = 1;
until (i > 5)?
  (i == 3)?
    print("Breaking at 3")
    print("\n")
    break  // Exit loop
  done
  print(i)
  print("\n")
  i += 1
done

# Nested conditionals with continue
let j: number = 1;
until (j > 3)?
  (j == 2)?
    print("Skipping 2")
    print("\n")
    continue  // Skip to next iteration
  done
  print(j)
  print("\n")
  j += 1
done

# Type checking with methods
let data = 42
(data.isnumber)?
  print("data is a number")
done
print("\n")

# Function calls
print(add(x, y))
print("\n")

let arr: number[] = [1, 2, 3]
print(sumarray(arr))
print("\n")

print(concat("Hello", "World"))
print("\n")
```

See `comprehensive_test.txt` for a complete test suite covering all COMET features.

## Implementation

- `lexer.l` - Flex lexical analyzer (COMET tokenization)
- `parser.y` - Bison parser with semantic actions (COMET to Lua translation)
- `Makefile` - Build configuration

The COMET compiler generates Lua code during parsing using semantic actions, which is then compiled to bytecode by LuaJIT.

## Clean

```bash
make clean
```

Removes compiled artifacts (parser binary and object files).
